import torch

# N is batch size; D_in is input dimension;
# H is hidden dimension; D_out is output dimension.
N, D_in, H, D_out = 64, 1000, 100, 10

dtype = torch.float
device = 'cuda' if torch.cuda.is_available() else 'cpu'
# N is batch size; D_in is input dimension;
# H is hidden dimension; D_out is output dimension. N, D_in, H, D_out = 64, 1000, 100, 10
# Create random input and output data
x = torch.randn(N, D_in, device=device, dtype=dtype)
y = torch.randn(N, D_out, device=device, dtype=dtype)
# Randomly initialize weights
w1 = torch.randn(D_in, H, device=device, dtype=dtype)
w2 = torch.randn(H, D_out, device=device, dtype=dtype)
learning_rate = 1e-6 
for t in range(500):
        # Forward pass: compute predicted y
        h = x.mm(w1)
        h_relu = h.clamp(min=0)
        y_pred = h_relu.mm(w2)
        # Compute and print loss
        loss = (y_pred - y).pow(2).sum().item() 
        print(t, loss)
        # Backprop to compute gradients of w1 and w2 with respect to loss
        grad_y_pred = 2.0 * (y_pred - y)
        grad_w2 = h_relu.t().mm(grad_y_pred)
        grad_h_relu = grad_y_pred.mm(w2.t())
        grad_h = grad_h_relu.clone()
        grad_h[h < 0] = 0
        grad_w1 = x.t().mm(grad_h)
        # Update weights using gradient descent
        w1 -= learning_rate * grad_w1
        w2 -= learning_rate * grad_w2

# ------------------------
# Demo: Python lists vs NumPy arrays
import numpy as np

print("Python list operations:")
a = [1,2,3]
b = [4,5,6]
print("a+b:", a + b)
try:
    print(a * b)
except TypeError:
    print("a*b has no meaning for Python lists")

print()
print("Numpy array operations:")
a = np.array([1,2,3])
b = np.array([4,5,6])
print("a+b:", a + b)
print("a*b:", a * b)

import numpy as np

# Define a 2D NumPy array (matrix)
a = np.array([[1, 2, 3],
              [4, 5, 6]])

print("a:")
print(a)

# Sum along columns (axis=0)
print("a.sum(axis=0):", a.sum(axis=0))   # [5 7 9]

# Sum along rows (axis=1)
print("a.sum(axis=1):", a.sum(axis=1))   # [ 6 15]

a = np.array([[1,2,3],
                  [4,5,6]])
b = np.array([10,20,30]) print("a+b:\n", a+b)

import numpy as np
from typing import List, Callable

# A Function takes in an ndarray as an argument and produces an ndarray
Array_Function = Callable[[np.ndarray], np.ndarray]

# A Chain is a list of such functions
Chain = List[Array_Function]


def chain_length_2(chain: Chain, a: np.ndarray) -> np.ndarray:
    """
    Evaluates two functions in a row, in a Chain of length 2.
    """
    assert len(chain) == 2, "Length of input 'chain' should be 2"
    f1 = chain[0]
    f2 = chain[1]
    return f2(f1(a))


# Example usage
def square(x: np.ndarray) -> np.ndarray:
    return x ** 2

def increment(x: np.ndarray) -> np.ndarray:
    return x + 1

chain = [square, increment]
x = np.array([1, 2, 3])

print("Input:", x)
print("Output:", chain_length_2(chain, x))



